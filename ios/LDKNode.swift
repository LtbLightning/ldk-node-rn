// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation
import SystemConfiguration

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(LDKNodeFFI)
import LDKNodeFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_ldk_node_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_ldk_node_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol Bolt11PaymentProtocol : AnyObject {
    
    func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage) throws 
    
    func failForHash(paymentHash: PaymentHash) throws 
    
    func receive(amountMsat: UInt64, description: String, expirySecs: UInt32) throws  -> Bolt11Invoice
    
    func receiveForHash(amountMsat: UInt64, description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws  -> Bolt11Invoice
    
    func receiveVariableAmount(description: String, expirySecs: UInt32) throws  -> Bolt11Invoice
    func receiveVariableAmountForHash(description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws  -> Bolt11Invoice
    
    func receiveVariableAmountViaJitChannel(description: String, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?) throws  -> Bolt11Invoice
    
    func receiveViaJitChannel(amountMsat: UInt64, description: String, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?) throws  -> Bolt11Invoice
    
    func send(invoice: Bolt11Invoice) throws  -> PaymentId
    
    func sendProbes(invoice: Bolt11Invoice) throws 
    
    func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws 
    
    func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws  -> PaymentId
    
}

public class Bolt11Payment:
    Bolt11PaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt11payment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_bolt11payment(pointer, $0) }
    }

    

    
    
    public func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_claim_for_hash(self.uniffiClonePointer(), 
        FfiConverterTypePaymentHash.lower(paymentHash),
        FfiConverterUInt64.lower(claimableAmountMsat),
        FfiConverterTypePaymentPreimage.lower(preimage),$0
    )
}
    }
    public func failForHash(paymentHash: PaymentHash) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_fail_for_hash(self.uniffiClonePointer(), 
        FfiConverterTypePaymentHash.lower(paymentHash),$0
    )
}
    }
    public func receive(amountMsat: UInt64, description: String, expirySecs: UInt32) throws  -> Bolt11Invoice {
        return try  FfiConverterTypeBolt11Invoice.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expirySecs),$0
    )
}
        )
    }
    public func receiveForHash(amountMsat: UInt64, description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws  -> Bolt11Invoice {
        return try  FfiConverterTypeBolt11Invoice.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_for_hash(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterTypePaymentHash.lower(paymentHash),$0
    )
}
        )
    }
    public func receiveVariableAmount(description: String, expirySecs: UInt32) throws  -> Bolt11Invoice {
        return try  FfiConverterTypeBolt11Invoice.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount(self.uniffiClonePointer(), 
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expirySecs),$0
    )
}
        )
    }
    public func receiveVariableAmountForHash(description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws  -> Bolt11Invoice {
        return try  FfiConverterTypeBolt11Invoice.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_for_hash(self.uniffiClonePointer(), 
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterTypePaymentHash.lower(paymentHash),$0
    )
}
        )
    }
    public func receiveVariableAmountViaJitChannel(description: String, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?) throws  -> Bolt11Invoice {
        return try  FfiConverterTypeBolt11Invoice.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel(self.uniffiClonePointer(), 
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterOptionUInt64.lower(maxProportionalLspFeeLimitPpmMsat),$0
    )
}
        )
    }
    public func receiveViaJitChannel(amountMsat: UInt64, description: String, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?) throws  -> Bolt11Invoice {
        return try  FfiConverterTypeBolt11Invoice.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterString.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterOptionUInt64.lower(maxLspFeeLimitMsat),$0
    )
}
        )
    }
    public func send(invoice: Bolt11Invoice) throws  -> PaymentId {
        return try  FfiConverterTypePaymentId.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send(self.uniffiClonePointer(), 
        FfiConverterTypeBolt11Invoice.lower(invoice),$0
    )
}
        )
    }
    public func sendProbes(invoice: Bolt11Invoice) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send_probes(self.uniffiClonePointer(), 
        FfiConverterTypeBolt11Invoice.lower(invoice),$0
    )
}
    }
    public func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send_probes_using_amount(self.uniffiClonePointer(), 
        FfiConverterTypeBolt11Invoice.lower(invoice),
        FfiConverterUInt64.lower(amountMsat),$0
    )
}
    }
    public func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws  -> PaymentId {
        return try  FfiConverterTypePaymentId.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send_using_amount(self.uniffiClonePointer(), 
        FfiConverterTypeBolt11Invoice.lower(invoice),
        FfiConverterUInt64.lower(amountMsat),$0
    )
}
        )
    }

}

public struct FfiConverterTypeBolt11Payment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt11Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
        return Bolt11Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt11Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeBolt11Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
    return try FfiConverterTypeBolt11Payment.lift(pointer)
}

public func FfiConverterTypeBolt11Payment_lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt11Payment.lower(value)
}




public protocol Bolt12PaymentProtocol : AnyObject {
    
    func initiateRefund(amountMsat: UInt64, expirySecs: UInt32) throws  -> Refund
    
    func receive(amountMsat: UInt64, description: String) throws  -> Offer
    
    func receiveVariableAmount(description: String) throws  -> Offer
    
    func requestRefundPayment(refund: Refund) throws  -> Bolt12Invoice
    
    func send(offer: Offer, payerNote: String?) throws  -> PaymentId
    
    func sendUsingAmount(offer: Offer, payerNote: String?, amountMsat: UInt64) throws  -> PaymentId
    
}

public class Bolt12Payment:
    Bolt12PaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt12payment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_bolt12payment(pointer, $0) }
    }

    

    
    
    public func initiateRefund(amountMsat: UInt64, expirySecs: UInt32) throws  -> Refund {
        return try  FfiConverterTypeRefund.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_initiate_refund(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterUInt32.lower(expirySecs),$0
    )
}
        )
    }
    public func receive(amountMsat: UInt64, description: String) throws  -> Offer {
        return try  FfiConverterTypeOffer.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_receive(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterString.lower(description),$0
    )
}
        )
    }
    public func receiveVariableAmount(description: String) throws  -> Offer {
        return try  FfiConverterTypeOffer.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_receive_variable_amount(self.uniffiClonePointer(), 
        FfiConverterString.lower(description),$0
    )
}
        )
    }
    public func requestRefundPayment(refund: Refund) throws  -> Bolt12Invoice {
        return try  FfiConverterTypeBolt12Invoice.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_request_refund_payment(self.uniffiClonePointer(), 
        FfiConverterTypeRefund.lower(refund),$0
    )
}
        )
    }
    public func send(offer: Offer, payerNote: String?) throws  -> PaymentId {
        return try  FfiConverterTypePaymentId.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_send(self.uniffiClonePointer(), 
        FfiConverterTypeOffer.lower(offer),
        FfiConverterOptionString.lower(payerNote),$0
    )
}
        )
    }
    public func sendUsingAmount(offer: Offer, payerNote: String?, amountMsat: UInt64) throws  -> PaymentId {
        return try  FfiConverterTypePaymentId.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_send_using_amount(self.uniffiClonePointer(), 
        FfiConverterTypeOffer.lower(offer),
        FfiConverterOptionString.lower(payerNote),
        FfiConverterUInt64.lower(amountMsat),$0
    )
}
        )
    }

}

public struct FfiConverterTypeBolt12Payment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt12Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
        return Bolt12Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt12Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeBolt12Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
    return try FfiConverterTypeBolt12Payment.lift(pointer)
}

public func FfiConverterTypeBolt12Payment_lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt12Payment.lower(value)
}




public protocol BuilderProtocol : AnyObject {
    
    func build() throws  -> Node
    
    func buildWithFsStore() throws  -> Node
    
    func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?) 
    
    func setEntropySeedBytes(seedBytes: [UInt8]) throws 
    
    func setEntropySeedPath(seedPath: String) 
    
    func setEsploraServer(esploraServerUrl: String) 
    
    func setGossipSourceP2p() 
    
    func setGossipSourceRgs(rgsServerUrl: String) 
    
    func setLiquiditySourceLsps2(address: SocketAddress, nodeId: PublicKey, token: String?) 
    
    func setListeningAddresses(listeningAddresses: [SocketAddress]) throws 
    
    func setNetwork(network: Network) 
    
    func setStorageDirPath(storageDirPath: String) 
    
}

public class Builder:
    BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_builder(self.pointer, $0) }
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_ldk_node_fn_constructor_builder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_builder(pointer, $0) }
    }

    
    public static func fromConfig(config: Config)  -> Builder {
        return Builder(unsafeFromRawPointer: try! rustCall() {
    uniffi_ldk_node_fn_constructor_builder_from_config(
        FfiConverterTypeConfig.lower(config),$0)
})
    }

    

    
    
    public func build() throws  -> Node {
        return try  FfiConverterTypeNode.lift(
            try 
    rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_build(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func buildWithFsStore() throws  -> Node {
        return try  FfiConverterTypeNode.lift(
            try 
    rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_build_with_fs_store(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_entropy_bip39_mnemonic(self.uniffiClonePointer(), 
        FfiConverterTypeMnemonic.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),$0
    )
}
    }
    public func setEntropySeedBytes(seedBytes: [UInt8]) throws  {
        try 
    rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_set_entropy_seed_bytes(self.uniffiClonePointer(), 
        FfiConverterSequenceUInt8.lower(seedBytes),$0
    )
}
    }
    public func setEntropySeedPath(seedPath: String)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_entropy_seed_path(self.uniffiClonePointer(), 
        FfiConverterString.lower(seedPath),$0
    )
}
    }
    public func setEsploraServer(esploraServerUrl: String)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_esplora_server(self.uniffiClonePointer(), 
        FfiConverterString.lower(esploraServerUrl),$0
    )
}
    }
    public func setGossipSourceP2p()  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_gossip_source_p2p(self.uniffiClonePointer(), $0
    )
}
    }
    public func setGossipSourceRgs(rgsServerUrl: String)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_gossip_source_rgs(self.uniffiClonePointer(), 
        FfiConverterString.lower(rgsServerUrl),$0
    )
}
    }
    public func setLiquiditySourceLsps2(address: SocketAddress, nodeId: PublicKey, token: String?)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps2(self.uniffiClonePointer(), 
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterOptionString.lower(token),$0
    )
}
    }
    public func setListeningAddresses(listeningAddresses: [SocketAddress]) throws  {
        try 
    rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_set_listening_addresses(self.uniffiClonePointer(), 
        FfiConverterSequenceTypeSocketAddress.lower(listeningAddresses),$0
    )
}
    }
    public func setNetwork(network: Network)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_network(self.uniffiClonePointer(), 
        FfiConverterTypeNetwork.lower(network),$0
    )
}
    }
    public func setStorageDirPath(storageDirPath: String)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_builder_set_storage_dir_path(self.uniffiClonePointer(), 
        FfiConverterString.lower(storageDirPath),$0
    )
}
    }

}

public struct FfiConverterTypeBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Builder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
        return Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Builder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
    return try FfiConverterTypeBuilder.lift(pointer)
}

public func FfiConverterTypeBuilder_lower(_ value: Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBuilder.lower(value)
}




public protocol ChannelConfigProtocol : AnyObject {
    
    func acceptUnderpayingHtlcs()  -> Bool
    
    func cltvExpiryDelta()  -> UInt16
    
    func forceCloseAvoidanceMaxFeeSatoshis()  -> UInt64
    
    func forwardingFeeBaseMsat()  -> UInt32
    
    func forwardingFeeProportionalMillionths()  -> UInt32
    
    func setAcceptUnderpayingHtlcs(value: Bool) 
    
    func setCltvExpiryDelta(value: UInt16) 
    
    func setForceCloseAvoidanceMaxFeeSatoshis(valueSat: UInt64) 
    
    func setForwardingFeeBaseMsat(feeMsat: UInt32) 
    
    func setForwardingFeeProportionalMillionths(value: UInt32) 
    
    func setMaxDustHtlcExposureFromFeeRateMultiplier(multiplier: UInt64) 
    
    func setMaxDustHtlcExposureFromFixedLimit(limitMsat: UInt64) 
    
}

public class ChannelConfig:
    ChannelConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_channelconfig(self.pointer, $0) }
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_ldk_node_fn_constructor_channelconfig_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_channelconfig(pointer, $0) }
    }

    

    
    
    public func acceptUnderpayingHtlcs()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_accept_underpaying_htlcs(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func cltvExpiryDelta()  -> UInt16 {
        return try!  FfiConverterUInt16.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_cltv_expiry_delta(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func forceCloseAvoidanceMaxFeeSatoshis()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_force_close_avoidance_max_fee_satoshis(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func forwardingFeeBaseMsat()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_forwarding_fee_base_msat(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func forwardingFeeProportionalMillionths()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_forwarding_fee_proportional_millionths(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func setAcceptUnderpayingHtlcs(value: Bool)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_set_accept_underpaying_htlcs(self.uniffiClonePointer(), 
        FfiConverterBool.lower(value),$0
    )
}
    }
    public func setCltvExpiryDelta(value: UInt16)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_set_cltv_expiry_delta(self.uniffiClonePointer(), 
        FfiConverterUInt16.lower(value),$0
    )
}
    }
    public func setForceCloseAvoidanceMaxFeeSatoshis(valueSat: UInt64)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_set_force_close_avoidance_max_fee_satoshis(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(valueSat),$0
    )
}
    }
    public func setForwardingFeeBaseMsat(feeMsat: UInt32)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_set_forwarding_fee_base_msat(self.uniffiClonePointer(), 
        FfiConverterUInt32.lower(feeMsat),$0
    )
}
    }
    public func setForwardingFeeProportionalMillionths(value: UInt32)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_set_forwarding_fee_proportional_millionths(self.uniffiClonePointer(), 
        FfiConverterUInt32.lower(value),$0
    )
}
    }
    public func setMaxDustHtlcExposureFromFeeRateMultiplier(multiplier: UInt64)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_set_max_dust_htlc_exposure_from_fee_rate_multiplier(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(multiplier),$0
    )
}
    }
    public func setMaxDustHtlcExposureFromFixedLimit(limitMsat: UInt64)  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_channelconfig_set_max_dust_htlc_exposure_from_fixed_limit(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(limitMsat),$0
    )
}
    }

}

public struct FfiConverterTypeChannelConfig: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ChannelConfig

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ChannelConfig {
        return ChannelConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ChannelConfig) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ChannelConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeChannelConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> ChannelConfig {
    return try FfiConverterTypeChannelConfig.lift(pointer)
}

public func FfiConverterTypeChannelConfig_lower(_ value: ChannelConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChannelConfig.lower(value)
}




public protocol NetworkGraphProtocol : AnyObject {
    
    func channel(shortChannelId: UInt64)  -> ChannelInfo?
    
    func listChannels()  -> [UInt64]
    
    func listNodes()  -> [NodeId]
    
    func node(nodeId: NodeId)  -> NodeInfo?
    
}

public class NetworkGraph:
    NetworkGraphProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_networkgraph(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_networkgraph(pointer, $0) }
    }

    

    
    
    public func channel(shortChannelId: UInt64)  -> ChannelInfo? {
        return try!  FfiConverterOptionTypeChannelInfo.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_networkgraph_channel(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(shortChannelId),$0
    )
}
        )
    }
    public func listChannels()  -> [UInt64] {
        return try!  FfiConverterSequenceUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_networkgraph_list_channels(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func listNodes()  -> [NodeId] {
        return try!  FfiConverterSequenceTypeNodeId.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_networkgraph_list_nodes(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func node(nodeId: NodeId)  -> NodeInfo? {
        return try!  FfiConverterOptionTypeNodeInfo.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_networkgraph_node(self.uniffiClonePointer(), 
        FfiConverterTypeNodeId.lower(nodeId),$0
    )
}
        )
    }

}

public struct FfiConverterTypeNetworkGraph: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkGraph

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
        return NetworkGraph(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkGraph {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkGraph, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNetworkGraph_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
    return try FfiConverterTypeNetworkGraph.lift(pointer)
}

public func FfiConverterTypeNetworkGraph_lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkGraph.lower(value)
}




public protocol NodeProtocol : AnyObject {
    
    func bolt11Payment()  -> Bolt11Payment
    
    func bolt12Payment()  -> Bolt12Payment
    
    func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws 
    
    func config()  -> Config
    
    func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool) throws 
    
    func connectOpenChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?, announceChannel: Bool) throws  -> UserChannelId
    
    func disconnect(nodeId: PublicKey) throws 
    
    func eventHandled() 
    
    func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws 
    
    func listBalances()  -> BalanceDetails
    
    func listChannels()  -> [ChannelDetails]
    
    func listPayments()  -> [PaymentDetails]
    
    func listPeers()  -> [PeerDetails]
    
    func listeningAddresses()  -> [SocketAddress]?
    
    func networkGraph()  -> NetworkGraph
    
    func nextEvent()  -> Event?
    
    func nextEventAsync() async  -> Event
    
    func nodeId()  -> PublicKey
    
    func onchainPayment()  -> OnchainPayment
    
    func payment(paymentId: PaymentId)  -> PaymentDetails?
    
    func removePayment(paymentId: PaymentId) throws 
    
    func signMessage(msg: [UInt8]) throws  -> String
    
    func spontaneousPayment()  -> SpontaneousPayment
    
    func start() throws 
    
    func status()  -> NodeStatus
    
    func stop() throws 
    
    func syncWallets() throws 
    
    func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig) throws 
    
    func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey)  -> Bool
    
    func waitNextEvent()  -> Event
    
}

public class Node:
    NodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_node(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_node(pointer, $0) }
    }

    

    
    
    public func bolt11Payment()  -> Bolt11Payment {
        return try!  FfiConverterTypeBolt11Payment.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_bolt11_payment(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func bolt12Payment()  -> Bolt12Payment {
        return try!  FfiConverterTypeBolt12Payment.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_bolt12_payment(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_close_channel(self.uniffiClonePointer(), 
        FfiConverterTypeUserChannelId.lower(userChannelId),
        FfiConverterTypePublicKey.lower(counterpartyNodeId),$0
    )
}
    }
    public func config()  -> Config {
        return try!  FfiConverterTypeConfig.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_config(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_connect(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterBool.lower(persist),$0
    )
}
    }
    public func connectOpenChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?, announceChannel: Bool) throws  -> UserChannelId {
        return try  FfiConverterTypeUserChannelId.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_connect_open_channel(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterUInt64.lower(channelAmountSats),
        FfiConverterOptionUInt64.lower(pushToCounterpartyMsat),
        FfiConverterOptionTypeChannelConfig.lower(channelConfig),
        FfiConverterBool.lower(announceChannel),$0
    )
}
        )
    }
    public func disconnect(nodeId: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_disconnect(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey.lower(nodeId),$0
    )
}
    }
    public func eventHandled()  {
        try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_event_handled(self.uniffiClonePointer(), $0
    )
}
    }
    public func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_force_close_channel(self.uniffiClonePointer(), 
        FfiConverterTypeUserChannelId.lower(userChannelId),
        FfiConverterTypePublicKey.lower(counterpartyNodeId),$0
    )
}
    }
    public func listBalances()  -> BalanceDetails {
        return try!  FfiConverterTypeBalanceDetails.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_list_balances(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func listChannels()  -> [ChannelDetails] {
        return try!  FfiConverterSequenceTypeChannelDetails.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_list_channels(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func listPayments()  -> [PaymentDetails] {
        return try!  FfiConverterSequenceTypePaymentDetails.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_list_payments(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func listPeers()  -> [PeerDetails] {
        return try!  FfiConverterSequenceTypePeerDetails.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_list_peers(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func listeningAddresses()  -> [SocketAddress]? {
        return try!  FfiConverterOptionSequenceTypeSocketAddress.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_listening_addresses(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func networkGraph()  -> NetworkGraph {
        return try!  FfiConverterTypeNetworkGraph.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_network_graph(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func nextEvent()  -> Event? {
        return try!  FfiConverterOptionTypeEvent.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_next_event(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func nextEventAsync() async  -> Event {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_ldk_node_fn_method_node_next_event_async(
                    self.uniffiClonePointer()
                )
            },
            pollFunc: ffi_ldk_node_rust_future_poll_rust_buffer,
            completeFunc: ffi_ldk_node_rust_future_complete_rust_buffer,
            freeFunc: ffi_ldk_node_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEvent.lift,
            errorHandler: nil
            
        )
    }

    
    public func nodeId()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_node_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func onchainPayment()  -> OnchainPayment {
        return try!  FfiConverterTypeOnchainPayment.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_onchain_payment(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func payment(paymentId: PaymentId)  -> PaymentDetails? {
        return try!  FfiConverterOptionTypePaymentDetails.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_payment(self.uniffiClonePointer(), 
        FfiConverterTypePaymentId.lower(paymentId),$0
    )
}
        )
    }
    public func removePayment(paymentId: PaymentId) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_remove_payment(self.uniffiClonePointer(), 
        FfiConverterTypePaymentId.lower(paymentId),$0
    )
}
    }
    public func signMessage(msg: [UInt8]) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_sign_message(self.uniffiClonePointer(), 
        FfiConverterSequenceUInt8.lower(msg),$0
    )
}
        )
    }
    public func spontaneousPayment()  -> SpontaneousPayment {
        return try!  FfiConverterTypeSpontaneousPayment.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_spontaneous_payment(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func start() throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_start(self.uniffiClonePointer(), $0
    )
}
    }
    public func status()  -> NodeStatus {
        return try!  FfiConverterTypeNodeStatus.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_status(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func stop() throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_stop(self.uniffiClonePointer(), $0
    )
}
    }
    public func syncWallets() throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_sync_wallets(self.uniffiClonePointer(), $0
    )
}
    }
    public func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_update_channel_config(self.uniffiClonePointer(), 
        FfiConverterTypeUserChannelId.lower(userChannelId),
        FfiConverterTypePublicKey.lower(counterpartyNodeId),
        FfiConverterTypeChannelConfig.lower(channelConfig),$0
    )
}
    }
    public func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_verify_signature(self.uniffiClonePointer(), 
        FfiConverterSequenceUInt8.lower(msg),
        FfiConverterString.lower(sig),
        FfiConverterTypePublicKey.lower(pkey),$0
    )
}
        )
    }
    public func waitNextEvent()  -> Event {
        return try!  FfiConverterTypeEvent.lift(
            try! 
    rustCall() {
    
    uniffi_ldk_node_fn_method_node_wait_next_event(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Node

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
        return Node(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Node) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
    return try FfiConverterTypeNode.lift(pointer)
}

public func FfiConverterTypeNode_lower(_ value: Node) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNode.lower(value)
}




public protocol OnchainPaymentProtocol : AnyObject {
    
    func newAddress() throws  -> Address
    
    func sendAllToAddress(address: Address) throws  -> Txid
    
    func sendToAddress(address: Address, amountMsat: UInt64) throws  -> Txid
    
}

public class OnchainPayment:
    OnchainPaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_onchainpayment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_onchainpayment(pointer, $0) }
    }

    

    
    
    public func newAddress() throws  -> Address {
        return try  FfiConverterTypeAddress.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_onchainpayment_new_address(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func sendAllToAddress(address: Address) throws  -> Txid {
        return try  FfiConverterTypeTxid.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_onchainpayment_send_all_to_address(self.uniffiClonePointer(), 
        FfiConverterTypeAddress.lower(address),$0
    )
}
        )
    }
    public func sendToAddress(address: Address, amountMsat: UInt64) throws  -> Txid {
        return try  FfiConverterTypeTxid.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_onchainpayment_send_to_address(self.uniffiClonePointer(), 
        FfiConverterTypeAddress.lower(address),
        FfiConverterUInt64.lower(amountMsat),$0
    )
}
        )
    }

}

public struct FfiConverterTypeOnchainPayment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OnchainPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
        return OnchainPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OnchainPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeOnchainPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
    return try FfiConverterTypeOnchainPayment.lift(pointer)
}

public func FfiConverterTypeOnchainPayment_lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOnchainPayment.lower(value)
}




public protocol SpontaneousPaymentProtocol : AnyObject {
    
    func send(amountMsat: UInt64, nodeId: PublicKey) throws  -> PaymentId
    
    func sendProbes(amountMsat: UInt64, nodeId: PublicKey) throws 
    
}

public class SpontaneousPayment:
    SpontaneousPaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_spontaneouspayment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_spontaneouspayment(pointer, $0) }
    }

    

    
    
    public func send(amountMsat: UInt64, nodeId: PublicKey) throws  -> PaymentId {
        return try  FfiConverterTypePaymentId.lift(
            try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_spontaneouspayment_send(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypePublicKey.lower(nodeId),$0
    )
}
        )
    }
    public func sendProbes(amountMsat: UInt64, nodeId: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_spontaneouspayment_send_probes(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypePublicKey.lower(nodeId),$0
    )
}
    }

}

public struct FfiConverterTypeSpontaneousPayment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SpontaneousPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
        return SpontaneousPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpontaneousPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SpontaneousPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeSpontaneousPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
    return try FfiConverterTypeSpontaneousPayment.lift(pointer)
}

public func FfiConverterTypeSpontaneousPayment_lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpontaneousPayment.lower(value)
}


public struct AnchorChannelsConfig {
    public var trustedPeersNoReserve: [PublicKey]
    public var perChannelReserveSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        trustedPeersNoReserve: [PublicKey], 
        perChannelReserveSats: UInt64) {
        self.trustedPeersNoReserve = trustedPeersNoReserve
        self.perChannelReserveSats = perChannelReserveSats
    }
}


extension AnchorChannelsConfig: Equatable, Hashable {
    public static func ==(lhs: AnchorChannelsConfig, rhs: AnchorChannelsConfig) -> Bool {
        if lhs.trustedPeersNoReserve != rhs.trustedPeersNoReserve {
            return false
        }
        if lhs.perChannelReserveSats != rhs.perChannelReserveSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(trustedPeersNoReserve)
        hasher.combine(perChannelReserveSats)
    }
}


public struct FfiConverterTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnchorChannelsConfig {
        return
            try AnchorChannelsConfig(
                trustedPeersNoReserve: FfiConverterSequenceTypePublicKey.read(from: &buf), 
                perChannelReserveSats: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AnchorChannelsConfig, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.trustedPeersNoReserve, into: &buf)
        FfiConverterUInt64.write(value.perChannelReserveSats, into: &buf)
    }
}


public func FfiConverterTypeAnchorChannelsConfig_lift(_ buf: RustBuffer) throws -> AnchorChannelsConfig {
    return try FfiConverterTypeAnchorChannelsConfig.lift(buf)
}

public func FfiConverterTypeAnchorChannelsConfig_lower(_ value: AnchorChannelsConfig) -> RustBuffer {
    return FfiConverterTypeAnchorChannelsConfig.lower(value)
}


public struct BalanceDetails {
    public var totalOnchainBalanceSats: UInt64
    public var spendableOnchainBalanceSats: UInt64
    public var totalAnchorChannelsReserveSats: UInt64
    public var totalLightningBalanceSats: UInt64
    public var lightningBalances: [LightningBalance]
    public var pendingBalancesFromChannelClosures: [PendingSweepBalance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        totalOnchainBalanceSats: UInt64, 
        spendableOnchainBalanceSats: UInt64, 
        totalAnchorChannelsReserveSats: UInt64, 
        totalLightningBalanceSats: UInt64, 
        lightningBalances: [LightningBalance], 
        pendingBalancesFromChannelClosures: [PendingSweepBalance]) {
        self.totalOnchainBalanceSats = totalOnchainBalanceSats
        self.spendableOnchainBalanceSats = spendableOnchainBalanceSats
        self.totalAnchorChannelsReserveSats = totalAnchorChannelsReserveSats
        self.totalLightningBalanceSats = totalLightningBalanceSats
        self.lightningBalances = lightningBalances
        self.pendingBalancesFromChannelClosures = pendingBalancesFromChannelClosures
    }
}


extension BalanceDetails: Equatable, Hashable {
    public static func ==(lhs: BalanceDetails, rhs: BalanceDetails) -> Bool {
        if lhs.totalOnchainBalanceSats != rhs.totalOnchainBalanceSats {
            return false
        }
        if lhs.spendableOnchainBalanceSats != rhs.spendableOnchainBalanceSats {
            return false
        }
        if lhs.totalAnchorChannelsReserveSats != rhs.totalAnchorChannelsReserveSats {
            return false
        }
        if lhs.totalLightningBalanceSats != rhs.totalLightningBalanceSats {
            return false
        }
        if lhs.lightningBalances != rhs.lightningBalances {
            return false
        }
        if lhs.pendingBalancesFromChannelClosures != rhs.pendingBalancesFromChannelClosures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalOnchainBalanceSats)
        hasher.combine(spendableOnchainBalanceSats)
        hasher.combine(totalAnchorChannelsReserveSats)
        hasher.combine(totalLightningBalanceSats)
        hasher.combine(lightningBalances)
        hasher.combine(pendingBalancesFromChannelClosures)
    }
}


public struct FfiConverterTypeBalanceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalanceDetails {
        return
            try BalanceDetails(
                totalOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), 
                spendableOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), 
                totalAnchorChannelsReserveSats: FfiConverterUInt64.read(from: &buf), 
                totalLightningBalanceSats: FfiConverterUInt64.read(from: &buf), 
                lightningBalances: FfiConverterSequenceTypeLightningBalance.read(from: &buf), 
                pendingBalancesFromChannelClosures: FfiConverterSequenceTypePendingSweepBalance.read(from: &buf)
        )
    }

    public static func write(_ value: BalanceDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.totalOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.spendableOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.totalAnchorChannelsReserveSats, into: &buf)
        FfiConverterUInt64.write(value.totalLightningBalanceSats, into: &buf)
        FfiConverterSequenceTypeLightningBalance.write(value.lightningBalances, into: &buf)
        FfiConverterSequenceTypePendingSweepBalance.write(value.pendingBalancesFromChannelClosures, into: &buf)
    }
}


public func FfiConverterTypeBalanceDetails_lift(_ buf: RustBuffer) throws -> BalanceDetails {
    return try FfiConverterTypeBalanceDetails.lift(buf)
}

public func FfiConverterTypeBalanceDetails_lower(_ value: BalanceDetails) -> RustBuffer {
    return FfiConverterTypeBalanceDetails.lower(value)
}


public struct BestBlock {
    public var blockHash: BlockHash
    public var height: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        blockHash: BlockHash, 
        height: UInt32) {
        self.blockHash = blockHash
        self.height = height
    }
}


extension BestBlock: Equatable, Hashable {
    public static func ==(lhs: BestBlock, rhs: BestBlock) -> Bool {
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockHash)
        hasher.combine(height)
    }
}


public struct FfiConverterTypeBestBlock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BestBlock {
        return
            try BestBlock(
                blockHash: FfiConverterTypeBlockHash.read(from: &buf), 
                height: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: BestBlock, into buf: inout [UInt8]) {
        FfiConverterTypeBlockHash.write(value.blockHash, into: &buf)
        FfiConverterUInt32.write(value.height, into: &buf)
    }
}


public func FfiConverterTypeBestBlock_lift(_ buf: RustBuffer) throws -> BestBlock {
    return try FfiConverterTypeBestBlock.lift(buf)
}

public func FfiConverterTypeBestBlock_lower(_ value: BestBlock) -> RustBuffer {
    return FfiConverterTypeBestBlock.lower(value)
}


public struct ChannelDetails {
    public var channelId: ChannelId
    public var counterpartyNodeId: PublicKey
    public var fundingTxo: OutPoint?
    public var channelValueSats: UInt64
    public var unspendablePunishmentReserve: UInt64?
    public var userChannelId: UserChannelId
    public var feerateSatPer1000Weight: UInt32
    public var outboundCapacityMsat: UInt64
    public var inboundCapacityMsat: UInt64
    public var confirmationsRequired: UInt32?
    public var confirmations: UInt32?
    public var isOutbound: Bool
    public var isChannelReady: Bool
    public var isUsable: Bool
    public var isPublic: Bool
    public var cltvExpiryDelta: UInt16?
    public var counterpartyUnspendablePunishmentReserve: UInt64
    public var counterpartyOutboundHtlcMinimumMsat: UInt64?
    public var counterpartyOutboundHtlcMaximumMsat: UInt64?
    public var counterpartyForwardingInfoFeeBaseMsat: UInt32?
    public var counterpartyForwardingInfoFeeProportionalMillionths: UInt32?
    public var counterpartyForwardingInfoCltvExpiryDelta: UInt16?
    public var nextOutboundHtlcLimitMsat: UInt64
    public var nextOutboundHtlcMinimumMsat: UInt64
    public var forceCloseSpendDelay: UInt16?
    public var inboundHtlcMinimumMsat: UInt64
    public var inboundHtlcMaximumMsat: UInt64?
    public var config: ChannelConfig

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        channelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        fundingTxo: OutPoint?, 
        channelValueSats: UInt64, 
        unspendablePunishmentReserve: UInt64?, 
        userChannelId: UserChannelId, 
        feerateSatPer1000Weight: UInt32, 
        outboundCapacityMsat: UInt64, 
        inboundCapacityMsat: UInt64, 
        confirmationsRequired: UInt32?, 
        confirmations: UInt32?, 
        isOutbound: Bool, 
        isChannelReady: Bool, 
        isUsable: Bool, 
        isPublic: Bool, 
        cltvExpiryDelta: UInt16?, 
        counterpartyUnspendablePunishmentReserve: UInt64, 
        counterpartyOutboundHtlcMinimumMsat: UInt64?, 
        counterpartyOutboundHtlcMaximumMsat: UInt64?, 
        counterpartyForwardingInfoFeeBaseMsat: UInt32?, 
        counterpartyForwardingInfoFeeProportionalMillionths: UInt32?, 
        counterpartyForwardingInfoCltvExpiryDelta: UInt16?, 
        nextOutboundHtlcLimitMsat: UInt64, 
        nextOutboundHtlcMinimumMsat: UInt64, 
        forceCloseSpendDelay: UInt16?, 
        inboundHtlcMinimumMsat: UInt64, 
        inboundHtlcMaximumMsat: UInt64?, 
        config: ChannelConfig) {
        self.channelId = channelId
        self.counterpartyNodeId = counterpartyNodeId
        self.fundingTxo = fundingTxo
        self.channelValueSats = channelValueSats
        self.unspendablePunishmentReserve = unspendablePunishmentReserve
        self.userChannelId = userChannelId
        self.feerateSatPer1000Weight = feerateSatPer1000Weight
        self.outboundCapacityMsat = outboundCapacityMsat
        self.inboundCapacityMsat = inboundCapacityMsat
        self.confirmationsRequired = confirmationsRequired
        self.confirmations = confirmations
        self.isOutbound = isOutbound
        self.isChannelReady = isChannelReady
        self.isUsable = isUsable
        self.isPublic = isPublic
        self.cltvExpiryDelta = cltvExpiryDelta
        self.counterpartyUnspendablePunishmentReserve = counterpartyUnspendablePunishmentReserve
        self.counterpartyOutboundHtlcMinimumMsat = counterpartyOutboundHtlcMinimumMsat
        self.counterpartyOutboundHtlcMaximumMsat = counterpartyOutboundHtlcMaximumMsat
        self.counterpartyForwardingInfoFeeBaseMsat = counterpartyForwardingInfoFeeBaseMsat
        self.counterpartyForwardingInfoFeeProportionalMillionths = counterpartyForwardingInfoFeeProportionalMillionths
        self.counterpartyForwardingInfoCltvExpiryDelta = counterpartyForwardingInfoCltvExpiryDelta
        self.nextOutboundHtlcLimitMsat = nextOutboundHtlcLimitMsat
        self.nextOutboundHtlcMinimumMsat = nextOutboundHtlcMinimumMsat
        self.forceCloseSpendDelay = forceCloseSpendDelay
        self.inboundHtlcMinimumMsat = inboundHtlcMinimumMsat
        self.inboundHtlcMaximumMsat = inboundHtlcMaximumMsat
        self.config = config
    }
}



public struct FfiConverterTypeChannelDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelDetails {
        return
            try ChannelDetails(
                channelId: FfiConverterTypeChannelId.read(from: &buf), 
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), 
                fundingTxo: FfiConverterOptionTypeOutPoint.read(from: &buf), 
                channelValueSats: FfiConverterUInt64.read(from: &buf), 
                unspendablePunishmentReserve: FfiConverterOptionUInt64.read(from: &buf), 
                userChannelId: FfiConverterTypeUserChannelId.read(from: &buf), 
                feerateSatPer1000Weight: FfiConverterUInt32.read(from: &buf), 
                outboundCapacityMsat: FfiConverterUInt64.read(from: &buf), 
                inboundCapacityMsat: FfiConverterUInt64.read(from: &buf), 
                confirmationsRequired: FfiConverterOptionUInt32.read(from: &buf), 
                confirmations: FfiConverterOptionUInt32.read(from: &buf), 
                isOutbound: FfiConverterBool.read(from: &buf), 
                isChannelReady: FfiConverterBool.read(from: &buf), 
                isUsable: FfiConverterBool.read(from: &buf), 
                isPublic: FfiConverterBool.read(from: &buf), 
                cltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf), 
                counterpartyUnspendablePunishmentReserve: FfiConverterUInt64.read(from: &buf), 
                counterpartyOutboundHtlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                counterpartyOutboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                counterpartyForwardingInfoFeeBaseMsat: FfiConverterOptionUInt32.read(from: &buf), 
                counterpartyForwardingInfoFeeProportionalMillionths: FfiConverterOptionUInt32.read(from: &buf), 
                counterpartyForwardingInfoCltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf), 
                nextOutboundHtlcLimitMsat: FfiConverterUInt64.read(from: &buf), 
                nextOutboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf), 
                forceCloseSpendDelay: FfiConverterOptionUInt16.read(from: &buf), 
                inboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf), 
                inboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                config: FfiConverterTypeChannelConfig.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelDetails, into buf: inout [UInt8]) {
        FfiConverterTypeChannelId.write(value.channelId, into: &buf)
        FfiConverterTypePublicKey.write(value.counterpartyNodeId, into: &buf)
        FfiConverterOptionTypeOutPoint.write(value.fundingTxo, into: &buf)
        FfiConverterUInt64.write(value.channelValueSats, into: &buf)
        FfiConverterOptionUInt64.write(value.unspendablePunishmentReserve, into: &buf)
        FfiConverterTypeUserChannelId.write(value.userChannelId, into: &buf)
        FfiConverterUInt32.write(value.feerateSatPer1000Weight, into: &buf)
        FfiConverterUInt64.write(value.outboundCapacityMsat, into: &buf)
        FfiConverterUInt64.write(value.inboundCapacityMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmationsRequired, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmations, into: &buf)
        FfiConverterBool.write(value.isOutbound, into: &buf)
        FfiConverterBool.write(value.isChannelReady, into: &buf)
        FfiConverterBool.write(value.isUsable, into: &buf)
        FfiConverterBool.write(value.isPublic, into: &buf)
        FfiConverterOptionUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.counterpartyUnspendablePunishmentReserve, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMaximumMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeBaseMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeProportionalMillionths, into: &buf)
        FfiConverterOptionUInt16.write(value.counterpartyForwardingInfoCltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcLimitMsat, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt16.write(value.forceCloseSpendDelay, into: &buf)
        FfiConverterUInt64.write(value.inboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.inboundHtlcMaximumMsat, into: &buf)
        FfiConverterTypeChannelConfig.write(value.config, into: &buf)
    }
}


public func FfiConverterTypeChannelDetails_lift(_ buf: RustBuffer) throws -> ChannelDetails {
    return try FfiConverterTypeChannelDetails.lift(buf)
}

public func FfiConverterTypeChannelDetails_lower(_ value: ChannelDetails) -> RustBuffer {
    return FfiConverterTypeChannelDetails.lower(value)
}


public struct ChannelInfo {
    public var nodeOne: NodeId
    public var oneToTwo: ChannelUpdateInfo?
    public var nodeTwo: NodeId
    public var twoToOne: ChannelUpdateInfo?
    public var capacitySats: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        nodeOne: NodeId, 
        oneToTwo: ChannelUpdateInfo?, 
        nodeTwo: NodeId, 
        twoToOne: ChannelUpdateInfo?, 
        capacitySats: UInt64?) {
        self.nodeOne = nodeOne
        self.oneToTwo = oneToTwo
        self.nodeTwo = nodeTwo
        self.twoToOne = twoToOne
        self.capacitySats = capacitySats
    }
}


extension ChannelInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelInfo, rhs: ChannelInfo) -> Bool {
        if lhs.nodeOne != rhs.nodeOne {
            return false
        }
        if lhs.oneToTwo != rhs.oneToTwo {
            return false
        }
        if lhs.nodeTwo != rhs.nodeTwo {
            return false
        }
        if lhs.twoToOne != rhs.twoToOne {
            return false
        }
        if lhs.capacitySats != rhs.capacitySats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeOne)
        hasher.combine(oneToTwo)
        hasher.combine(nodeTwo)
        hasher.combine(twoToOne)
        hasher.combine(capacitySats)
    }
}


public struct FfiConverterTypeChannelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelInfo {
        return
            try ChannelInfo(
                nodeOne: FfiConverterTypeNodeId.read(from: &buf), 
                oneToTwo: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf), 
                nodeTwo: FfiConverterTypeNodeId.read(from: &buf), 
                twoToOne: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf), 
                capacitySats: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelInfo, into buf: inout [UInt8]) {
        FfiConverterTypeNodeId.write(value.nodeOne, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.oneToTwo, into: &buf)
        FfiConverterTypeNodeId.write(value.nodeTwo, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.twoToOne, into: &buf)
        FfiConverterOptionUInt64.write(value.capacitySats, into: &buf)
    }
}


public func FfiConverterTypeChannelInfo_lift(_ buf: RustBuffer) throws -> ChannelInfo {
    return try FfiConverterTypeChannelInfo.lift(buf)
}

public func FfiConverterTypeChannelInfo_lower(_ value: ChannelInfo) -> RustBuffer {
    return FfiConverterTypeChannelInfo.lower(value)
}


public struct ChannelUpdateInfo {
    public var lastUpdate: UInt32
    public var enabled: Bool
    public var cltvExpiryDelta: UInt16
    public var htlcMinimumMsat: UInt64
    public var htlcMaximumMsat: UInt64
    public var fees: RoutingFees

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        lastUpdate: UInt32, 
        enabled: Bool, 
        cltvExpiryDelta: UInt16, 
        htlcMinimumMsat: UInt64, 
        htlcMaximumMsat: UInt64, 
        fees: RoutingFees) {
        self.lastUpdate = lastUpdate
        self.enabled = enabled
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
        self.fees = fees
    }
}


extension ChannelUpdateInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelUpdateInfo, rhs: ChannelUpdateInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.enabled != rhs.enabled {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(enabled)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
        hasher.combine(fees)
    }
}


public struct FfiConverterTypeChannelUpdateInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelUpdateInfo {
        return
            try ChannelUpdateInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf), 
                enabled: FfiConverterBool.read(from: &buf), 
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf), 
                htlcMinimumMsat: FfiConverterUInt64.read(from: &buf), 
                htlcMaximumMsat: FfiConverterUInt64.read(from: &buf), 
                fees: FfiConverterTypeRoutingFees.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelUpdateInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterUInt64.write(value.htlcMaximumMsat, into: &buf)
        FfiConverterTypeRoutingFees.write(value.fees, into: &buf)
    }
}


public func FfiConverterTypeChannelUpdateInfo_lift(_ buf: RustBuffer) throws -> ChannelUpdateInfo {
    return try FfiConverterTypeChannelUpdateInfo.lift(buf)
}

public func FfiConverterTypeChannelUpdateInfo_lower(_ value: ChannelUpdateInfo) -> RustBuffer {
    return FfiConverterTypeChannelUpdateInfo.lower(value)
}


public struct Config {
    public var storageDirPath: String
    public var logDirPath: String?
    public var network: Network
    public var listeningAddresses: [SocketAddress]?
    public var defaultCltvExpiryDelta: UInt32
    public var onchainWalletSyncIntervalSecs: UInt64
    public var walletSyncIntervalSecs: UInt64
    public var feeRateCacheUpdateIntervalSecs: UInt64
    public var trustedPeers0conf: [PublicKey]
    public var probingLiquidityLimitMultiplier: UInt64
    public var logLevel: LogLevel
    public var anchorChannelsConfig: AnchorChannelsConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        storageDirPath: String, 
        logDirPath: String?, 
        network: Network, 
        listeningAddresses: [SocketAddress]?, 
        defaultCltvExpiryDelta: UInt32, 
        onchainWalletSyncIntervalSecs: UInt64, 
        walletSyncIntervalSecs: UInt64, 
        feeRateCacheUpdateIntervalSecs: UInt64, 
        trustedPeers0conf: [PublicKey], 
        probingLiquidityLimitMultiplier: UInt64, 
        logLevel: LogLevel, 
        anchorChannelsConfig: AnchorChannelsConfig? = nil) {
        self.storageDirPath = storageDirPath
        self.logDirPath = logDirPath
        self.network = network
        self.listeningAddresses = listeningAddresses
        self.defaultCltvExpiryDelta = defaultCltvExpiryDelta
        self.onchainWalletSyncIntervalSecs = onchainWalletSyncIntervalSecs
        self.walletSyncIntervalSecs = walletSyncIntervalSecs
        self.feeRateCacheUpdateIntervalSecs = feeRateCacheUpdateIntervalSecs
        self.trustedPeers0conf = trustedPeers0conf
        self.probingLiquidityLimitMultiplier = probingLiquidityLimitMultiplier
        self.logLevel = logLevel
        self.anchorChannelsConfig = anchorChannelsConfig
    }
}


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.storageDirPath != rhs.storageDirPath {
            return false
        }
        if lhs.logDirPath != rhs.logDirPath {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.listeningAddresses != rhs.listeningAddresses {
            return false
        }
        if lhs.defaultCltvExpiryDelta != rhs.defaultCltvExpiryDelta {
            return false
        }
        if lhs.onchainWalletSyncIntervalSecs != rhs.onchainWalletSyncIntervalSecs {
            return false
        }
        if lhs.walletSyncIntervalSecs != rhs.walletSyncIntervalSecs {
            return false
        }
        if lhs.feeRateCacheUpdateIntervalSecs != rhs.feeRateCacheUpdateIntervalSecs {
            return false
        }
        if lhs.trustedPeers0conf != rhs.trustedPeers0conf {
            return false
        }
        if lhs.probingLiquidityLimitMultiplier != rhs.probingLiquidityLimitMultiplier {
            return false
        }
        if lhs.logLevel != rhs.logLevel {
            return false
        }
        if lhs.anchorChannelsConfig != rhs.anchorChannelsConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(storageDirPath)
        hasher.combine(logDirPath)
        hasher.combine(network)
        hasher.combine(listeningAddresses)
        hasher.combine(defaultCltvExpiryDelta)
        hasher.combine(onchainWalletSyncIntervalSecs)
        hasher.combine(walletSyncIntervalSecs)
        hasher.combine(feeRateCacheUpdateIntervalSecs)
        hasher.combine(trustedPeers0conf)
        hasher.combine(probingLiquidityLimitMultiplier)
        hasher.combine(logLevel)
        hasher.combine(anchorChannelsConfig)
    }
}


public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                storageDirPath: FfiConverterString.read(from: &buf), 
                logDirPath: FfiConverterOptionString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                listeningAddresses: FfiConverterOptionSequenceTypeSocketAddress.read(from: &buf), 
                defaultCltvExpiryDelta: FfiConverterUInt32.read(from: &buf), 
                onchainWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf), 
                walletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf), 
                feeRateCacheUpdateIntervalSecs: FfiConverterUInt64.read(from: &buf), 
                trustedPeers0conf: FfiConverterSequenceTypePublicKey.read(from: &buf), 
                probingLiquidityLimitMultiplier: FfiConverterUInt64.read(from: &buf), 
                logLevel: FfiConverterTypeLogLevel.read(from: &buf), 
                anchorChannelsConfig: FfiConverterOptionTypeAnchorChannelsConfig.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.storageDirPath, into: &buf)
        FfiConverterOptionString.write(value.logDirPath, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterOptionSequenceTypeSocketAddress.write(value.listeningAddresses, into: &buf)
        FfiConverterUInt32.write(value.defaultCltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.onchainWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.walletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.feeRateCacheUpdateIntervalSecs, into: &buf)
        FfiConverterSequenceTypePublicKey.write(value.trustedPeers0conf, into: &buf)
        FfiConverterUInt64.write(value.probingLiquidityLimitMultiplier, into: &buf)
        FfiConverterTypeLogLevel.write(value.logLevel, into: &buf)
        FfiConverterOptionTypeAnchorChannelsConfig.write(value.anchorChannelsConfig, into: &buf)
    }
}


public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct LspFeeLimits {
    public var maxTotalOpeningFeeMsat: UInt64?
    public var maxProportionalOpeningFeePpmMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        maxTotalOpeningFeeMsat: UInt64?, 
        maxProportionalOpeningFeePpmMsat: UInt64?) {
        self.maxTotalOpeningFeeMsat = maxTotalOpeningFeeMsat
        self.maxProportionalOpeningFeePpmMsat = maxProportionalOpeningFeePpmMsat
    }
}


extension LspFeeLimits: Equatable, Hashable {
    public static func ==(lhs: LspFeeLimits, rhs: LspFeeLimits) -> Bool {
        if lhs.maxTotalOpeningFeeMsat != rhs.maxTotalOpeningFeeMsat {
            return false
        }
        if lhs.maxProportionalOpeningFeePpmMsat != rhs.maxProportionalOpeningFeePpmMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxTotalOpeningFeeMsat)
        hasher.combine(maxProportionalOpeningFeePpmMsat)
    }
}


public struct FfiConverterTypeLSPFeeLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspFeeLimits {
        return
            try LspFeeLimits(
                maxTotalOpeningFeeMsat: FfiConverterOptionUInt64.read(from: &buf), 
                maxProportionalOpeningFeePpmMsat: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LspFeeLimits, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.maxTotalOpeningFeeMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.maxProportionalOpeningFeePpmMsat, into: &buf)
    }
}


public func FfiConverterTypeLSPFeeLimits_lift(_ buf: RustBuffer) throws -> LspFeeLimits {
    return try FfiConverterTypeLSPFeeLimits.lift(buf)
}

public func FfiConverterTypeLSPFeeLimits_lower(_ value: LspFeeLimits) -> RustBuffer {
    return FfiConverterTypeLSPFeeLimits.lower(value)
}


public struct NodeAnnouncementInfo {
    public var lastUpdate: UInt32
    public var alias: String
    public var addresses: [SocketAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        lastUpdate: UInt32, 
        alias: String, 
        addresses: [SocketAddress]) {
        self.lastUpdate = lastUpdate
        self.alias = alias
        self.addresses = addresses
    }
}


extension NodeAnnouncementInfo: Equatable, Hashable {
    public static func ==(lhs: NodeAnnouncementInfo, rhs: NodeAnnouncementInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.addresses != rhs.addresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(alias)
        hasher.combine(addresses)
    }
}


public struct FfiConverterTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAnnouncementInfo {
        return
            try NodeAnnouncementInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf), 
                alias: FfiConverterString.read(from: &buf), 
                addresses: FfiConverterSequenceTypeSocketAddress.read(from: &buf)
        )
    }

    public static func write(_ value: NodeAnnouncementInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterString.write(value.alias, into: &buf)
        FfiConverterSequenceTypeSocketAddress.write(value.addresses, into: &buf)
    }
}


public func FfiConverterTypeNodeAnnouncementInfo_lift(_ buf: RustBuffer) throws -> NodeAnnouncementInfo {
    return try FfiConverterTypeNodeAnnouncementInfo.lift(buf)
}

public func FfiConverterTypeNodeAnnouncementInfo_lower(_ value: NodeAnnouncementInfo) -> RustBuffer {
    return FfiConverterTypeNodeAnnouncementInfo.lower(value)
}


public struct NodeInfo {
    public var channels: [UInt64]
    public var announcementInfo: NodeAnnouncementInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        channels: [UInt64], 
        announcementInfo: NodeAnnouncementInfo?) {
        self.channels = channels
        self.announcementInfo = announcementInfo
    }
}


extension NodeInfo: Equatable, Hashable {
    public static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.channels != rhs.channels {
            return false
        }
        if lhs.announcementInfo != rhs.announcementInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channels)
        hasher.combine(announcementInfo)
    }
}


public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return
            try NodeInfo(
                channels: FfiConverterSequenceUInt64.read(from: &buf), 
                announcementInfo: FfiConverterOptionTypeNodeAnnouncementInfo.read(from: &buf)
        )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt64.write(value.channels, into: &buf)
        FfiConverterOptionTypeNodeAnnouncementInfo.write(value.announcementInfo, into: &buf)
    }
}


public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}


public struct NodeStatus {
    public var isRunning: Bool
    public var isListening: Bool
    public var currentBestBlock: BestBlock
    public var latestWalletSyncTimestamp: UInt64?
    public var latestOnchainWalletSyncTimestamp: UInt64?
    public var latestFeeRateCacheUpdateTimestamp: UInt64?
    public var latestRgsSnapshotTimestamp: UInt64?
    public var latestNodeAnnouncementBroadcastTimestamp: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        isRunning: Bool, 
        isListening: Bool, 
        currentBestBlock: BestBlock, 
        latestWalletSyncTimestamp: UInt64?, 
        latestOnchainWalletSyncTimestamp: UInt64?, 
        latestFeeRateCacheUpdateTimestamp: UInt64?, 
        latestRgsSnapshotTimestamp: UInt64?, 
        latestNodeAnnouncementBroadcastTimestamp: UInt64?) {
        self.isRunning = isRunning
        self.isListening = isListening
        self.currentBestBlock = currentBestBlock
        self.latestWalletSyncTimestamp = latestWalletSyncTimestamp
        self.latestOnchainWalletSyncTimestamp = latestOnchainWalletSyncTimestamp
        self.latestFeeRateCacheUpdateTimestamp = latestFeeRateCacheUpdateTimestamp
        self.latestRgsSnapshotTimestamp = latestRgsSnapshotTimestamp
        self.latestNodeAnnouncementBroadcastTimestamp = latestNodeAnnouncementBroadcastTimestamp
    }
}


extension NodeStatus: Equatable, Hashable {
    public static func ==(lhs: NodeStatus, rhs: NodeStatus) -> Bool {
        if lhs.isRunning != rhs.isRunning {
            return false
        }
        if lhs.isListening != rhs.isListening {
            return false
        }
        if lhs.currentBestBlock != rhs.currentBestBlock {
            return false
        }
        if lhs.latestWalletSyncTimestamp != rhs.latestWalletSyncTimestamp {
            return false
        }
        if lhs.latestOnchainWalletSyncTimestamp != rhs.latestOnchainWalletSyncTimestamp {
            return false
        }
        if lhs.latestFeeRateCacheUpdateTimestamp != rhs.latestFeeRateCacheUpdateTimestamp {
            return false
        }
        if lhs.latestRgsSnapshotTimestamp != rhs.latestRgsSnapshotTimestamp {
            return false
        }
        if lhs.latestNodeAnnouncementBroadcastTimestamp != rhs.latestNodeAnnouncementBroadcastTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRunning)
        hasher.combine(isListening)
        hasher.combine(currentBestBlock)
        hasher.combine(latestWalletSyncTimestamp)
        hasher.combine(latestOnchainWalletSyncTimestamp)
        hasher.combine(latestFeeRateCacheUpdateTimestamp)
        hasher.combine(latestRgsSnapshotTimestamp)
        hasher.combine(latestNodeAnnouncementBroadcastTimestamp)
    }
}


public struct FfiConverterTypeNodeStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStatus {
        return
            try NodeStatus(
                isRunning: FfiConverterBool.read(from: &buf), 
                isListening: FfiConverterBool.read(from: &buf), 
                currentBestBlock: FfiConverterTypeBestBlock.read(from: &buf), 
                latestWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestOnchainWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestFeeRateCacheUpdateTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestRgsSnapshotTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestNodeAnnouncementBroadcastTimestamp: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NodeStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRunning, into: &buf)
        FfiConverterBool.write(value.isListening, into: &buf)
        FfiConverterTypeBestBlock.write(value.currentBestBlock, into: &buf)
        FfiConverterOptionUInt64.write(value.latestWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestOnchainWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestFeeRateCacheUpdateTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestRgsSnapshotTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestNodeAnnouncementBroadcastTimestamp, into: &buf)
    }
}


public func FfiConverterTypeNodeStatus_lift(_ buf: RustBuffer) throws -> NodeStatus {
    return try FfiConverterTypeNodeStatus.lift(buf)
}

public func FfiConverterTypeNodeStatus_lower(_ value: NodeStatus) -> RustBuffer {
    return FfiConverterTypeNodeStatus.lower(value)
}


public struct OutPoint {
    public var txid: Txid
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        txid: Txid, 
        vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}


extension OutPoint: Equatable, Hashable {
    public static func ==(lhs: OutPoint, rhs: OutPoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}


public struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        return
            try OutPoint(
                txid: FfiConverterTypeTxid.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}


public func FfiConverterTypeOutPoint_lift(_ buf: RustBuffer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(buf)
}

public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> RustBuffer {
    return FfiConverterTypeOutPoint.lower(value)
}


public struct PaymentDetails {
    public var id: PaymentId
    public var kind: PaymentKind
    public var amountMsat: UInt64?
    public var direction: PaymentDirection
    public var status: PaymentStatus
    public var latestUpdateTimestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: PaymentId, 
        kind: PaymentKind, 
        amountMsat: UInt64?, 
        direction: PaymentDirection, 
        status: PaymentStatus, 
        latestUpdateTimestamp: UInt64) {
        self.id = id
        self.kind = kind
        self.amountMsat = amountMsat
        self.direction = direction
        self.status = status
        self.latestUpdateTimestamp = latestUpdateTimestamp
    }
}


extension PaymentDetails: Equatable, Hashable {
    public static func ==(lhs: PaymentDetails, rhs: PaymentDetails) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.latestUpdateTimestamp != rhs.latestUpdateTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(kind)
        hasher.combine(amountMsat)
        hasher.combine(direction)
        hasher.combine(status)
        hasher.combine(latestUpdateTimestamp)
    }
}


public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        return
            try PaymentDetails(
                id: FfiConverterTypePaymentId.read(from: &buf), 
                kind: FfiConverterTypePaymentKind.read(from: &buf), 
                amountMsat: FfiConverterOptionUInt64.read(from: &buf), 
                direction: FfiConverterTypePaymentDirection.read(from: &buf), 
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                latestUpdateTimestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        FfiConverterTypePaymentId.write(value.id, into: &buf)
        FfiConverterTypePaymentKind.write(value.kind, into: &buf)
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterTypePaymentDirection.write(value.direction, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterUInt64.write(value.latestUpdateTimestamp, into: &buf)
    }
}


public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}


public struct PeerDetails {
    public var nodeId: PublicKey
    public var address: SocketAddress
    public var isPersisted: Bool
    public var isConnected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        nodeId: PublicKey, 
        address: SocketAddress, 
        isPersisted: Bool, 
        isConnected: Bool) {
        self.nodeId = nodeId
        self.address = address
        self.isPersisted = isPersisted
        self.isConnected = isConnected
    }
}


extension PeerDetails: Equatable, Hashable {
    public static func ==(lhs: PeerDetails, rhs: PeerDetails) -> Bool {
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.isPersisted != rhs.isPersisted {
            return false
        }
        if lhs.isConnected != rhs.isConnected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeId)
        hasher.combine(address)
        hasher.combine(isPersisted)
        hasher.combine(isConnected)
    }
}


public struct FfiConverterTypePeerDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PeerDetails {
        return
            try PeerDetails(
                nodeId: FfiConverterTypePublicKey.read(from: &buf), 
                address: FfiConverterTypeSocketAddress.read(from: &buf), 
                isPersisted: FfiConverterBool.read(from: &buf), 
                isConnected: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PeerDetails, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.nodeId, into: &buf)
        FfiConverterTypeSocketAddress.write(value.address, into: &buf)
        FfiConverterBool.write(value.isPersisted, into: &buf)
        FfiConverterBool.write(value.isConnected, into: &buf)
    }
}


public func FfiConverterTypePeerDetails_lift(_ buf: RustBuffer) throws -> PeerDetails {
    return try FfiConverterTypePeerDetails.lift(buf)
}

public func FfiConverterTypePeerDetails_lower(_ value: PeerDetails) -> RustBuffer {
    return FfiConverterTypePeerDetails.lower(value)
}


public struct RoutingFees {
    public var baseMsat: UInt32
    public var proportionalMillionths: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        baseMsat: UInt32, 
        proportionalMillionths: UInt32) {
        self.baseMsat = baseMsat
        self.proportionalMillionths = proportionalMillionths
    }
}


extension RoutingFees: Equatable, Hashable {
    public static func ==(lhs: RoutingFees, rhs: RoutingFees) -> Bool {
        if lhs.baseMsat != rhs.baseMsat {
            return false
        }
        if lhs.proportionalMillionths != rhs.proportionalMillionths {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseMsat)
        hasher.combine(proportionalMillionths)
    }
}


public struct FfiConverterTypeRoutingFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoutingFees {
        return
            try RoutingFees(
                baseMsat: FfiConverterUInt32.read(from: &buf), 
                proportionalMillionths: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RoutingFees, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.baseMsat, into: &buf)
        FfiConverterUInt32.write(value.proportionalMillionths, into: &buf)
    }
}


public func FfiConverterTypeRoutingFees_lift(_ buf: RustBuffer) throws -> RoutingFees {
    return try FfiConverterTypeRoutingFees.lift(buf)
}

public func FfiConverterTypeRoutingFees_lower(_ value: RoutingFees) -> RustBuffer {
    return FfiConverterTypeRoutingFees.lower(value)
}


public enum BuildError {

    
    
    case InvalidSeedBytes(message: String)
    
    case InvalidSeedFile(message: String)
    
    case InvalidSystemTime(message: String)
    
    case InvalidChannelMonitor(message: String)
    
    case InvalidListeningAddresses(message: String)
    
    case ReadFailed(message: String)
    
    case WriteFailed(message: String)
    
    case StoragePathAccessFailed(message: String)
    
    case KvStoreSetupFailed(message: String)
    
    case WalletSetupFailed(message: String)
    
    case LoggerSetupFailed(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeBuildError.lift(error)
    }
}


public struct FfiConverterTypeBuildError: FfiConverterRustBuffer {
    typealias SwiftType = BuildError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuildError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSeedBytes(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidSeedFile(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidSystemTime(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidChannelMonitor(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidListeningAddresses(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .ReadFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .WriteFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .StoragePathAccessFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .KvStoreSetupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .WalletSetupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .LoggerSetupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BuildError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidSeedBytes(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidSeedFile(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidSystemTime(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidChannelMonitor(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidListeningAddresses(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .ReadFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .WriteFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .StoragePathAccessFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .KvStoreSetupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .WalletSetupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .LoggerSetupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))

        
        }
    }
}


extension BuildError: Equatable, Hashable {}

extension BuildError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ClosureReason {
    
    case counterpartyForceClosed(
        peerMsg: UntrustedString
    )
    case holderForceClosed
    case legacyCooperativeClosure
    case counterpartyInitiatedCooperativeClosure
    case locallyInitiatedCooperativeClosure
    case commitmentTxConfirmed
    case fundingTimedOut
    case processingError(
        err: String
    )
    case disconnectedPeer
    case outdatedChannelManager
    case counterpartyCoopClosedUnfundedChannel
    case fundingBatchClosure
    case htlCsTimedOut
}

public struct FfiConverterTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClosureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .counterpartyForceClosed(
            peerMsg: try FfiConverterTypeUntrustedString.read(from: &buf)
        )
        
        case 2: return .holderForceClosed
        
        case 3: return .legacyCooperativeClosure
        
        case 4: return .counterpartyInitiatedCooperativeClosure
        
        case 5: return .locallyInitiatedCooperativeClosure
        
        case 6: return .commitmentTxConfirmed
        
        case 7: return .fundingTimedOut
        
        case 8: return .processingError(
            err: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .disconnectedPeer
        
        case 10: return .outdatedChannelManager
        
        case 11: return .counterpartyCoopClosedUnfundedChannel
        
        case 12: return .fundingBatchClosure
        
        case 13: return .htlCsTimedOut
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClosureReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .counterpartyForceClosed(peerMsg):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUntrustedString.write(peerMsg, into: &buf)
            
        
        case .holderForceClosed:
            writeInt(&buf, Int32(2))
        
        
        case .legacyCooperativeClosure:
            writeInt(&buf, Int32(3))
        
        
        case .counterpartyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(4))
        
        
        case .locallyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(5))
        
        
        case .commitmentTxConfirmed:
            writeInt(&buf, Int32(6))
        
        
        case .fundingTimedOut:
            writeInt(&buf, Int32(7))
        
        
        case let .processingError(err):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(err, into: &buf)
            
        
        case .disconnectedPeer:
            writeInt(&buf, Int32(9))
        
        
        case .outdatedChannelManager:
            writeInt(&buf, Int32(10))
        
        
        case .counterpartyCoopClosedUnfundedChannel:
            writeInt(&buf, Int32(11))
        
        
        case .fundingBatchClosure:
            writeInt(&buf, Int32(12))
        
        
        case .htlCsTimedOut:
            writeInt(&buf, Int32(13))
        
        }
    }
}


public func FfiConverterTypeClosureReason_lift(_ buf: RustBuffer) throws -> ClosureReason {
    return try FfiConverterTypeClosureReason.lift(buf)
}

public func FfiConverterTypeClosureReason_lower(_ value: ClosureReason) -> RustBuffer {
    return FfiConverterTypeClosureReason.lower(value)
}


extension ClosureReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Event {
    
    case paymentSuccessful(
        paymentId: PaymentId?, 
        paymentHash: PaymentHash, 
        feePaidMsat: UInt64?
    )
    case paymentFailed(
        paymentId: PaymentId?, 
        paymentHash: PaymentHash, 
        reason: PaymentFailureReason?
    )
    case paymentReceived(
        paymentId: PaymentId?, 
        paymentHash: PaymentHash, 
        amountMsat: UInt64
    )
    case paymentClaimable(
        paymentId: PaymentId, 
        paymentHash: PaymentHash, 
        claimableAmountMsat: UInt64, 
        claimDeadline: UInt32?
    )
    case channelPending(
        channelId: ChannelId, 
        userChannelId: UserChannelId, 
        formerTemporaryChannelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        fundingTxo: OutPoint
    )
    case channelReady(
        channelId: ChannelId, 
        userChannelId: UserChannelId, 
        counterpartyNodeId: PublicKey?
    )
    case channelClosed(
        channelId: ChannelId, 
        userChannelId: UserChannelId, 
        counterpartyNodeId: PublicKey?, 
        reason: ClosureReason?
    )
}

public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .paymentSuccessful(
            paymentId: try FfiConverterOptionTypePaymentId.read(from: &buf), 
            paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), 
            feePaidMsat: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 2: return .paymentFailed(
            paymentId: try FfiConverterOptionTypePaymentId.read(from: &buf), 
            paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), 
            reason: try FfiConverterOptionTypePaymentFailureReason.read(from: &buf)
        )
        
        case 3: return .paymentReceived(
            paymentId: try FfiConverterOptionTypePaymentId.read(from: &buf), 
            paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), 
            amountMsat: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 4: return .paymentClaimable(
            paymentId: try FfiConverterTypePaymentId.read(from: &buf), 
            paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), 
            claimableAmountMsat: try FfiConverterUInt64.read(from: &buf), 
            claimDeadline: try FfiConverterOptionUInt32.read(from: &buf)
        )
        
        case 5: return .channelPending(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            userChannelId: try FfiConverterTypeUserChannelId.read(from: &buf), 
            formerTemporaryChannelId: try FfiConverterTypeChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), 
            fundingTxo: try FfiConverterTypeOutPoint.read(from: &buf)
        )
        
        case 6: return .channelReady(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            userChannelId: try FfiConverterTypeUserChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterOptionTypePublicKey.read(from: &buf)
        )
        
        case 7: return .channelClosed(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            userChannelId: try FfiConverterTypeUserChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterOptionTypePublicKey.read(from: &buf), 
            reason: try FfiConverterOptionTypeClosureReason.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .paymentSuccessful(paymentId,paymentHash,feePaidMsat):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionUInt64.write(feePaidMsat, into: &buf)
            
        
        case let .paymentFailed(paymentId,paymentHash,reason):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionTypePaymentFailureReason.write(reason, into: &buf)
            
        
        case let .paymentReceived(paymentId,paymentHash,amountMsat):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(amountMsat, into: &buf)
            
        
        case let .paymentClaimable(paymentId,paymentHash,claimableAmountMsat,claimDeadline):
            writeInt(&buf, Int32(4))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(claimableAmountMsat, into: &buf)
            FfiConverterOptionUInt32.write(claimDeadline, into: &buf)
            
        
        case let .channelPending(channelId,userChannelId,formerTemporaryChannelId,counterpartyNodeId,fundingTxo):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterTypeChannelId.write(formerTemporaryChannelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterTypeOutPoint.write(fundingTxo, into: &buf)
            
        
        case let .channelReady(channelId,userChannelId,counterpartyNodeId):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)
            
        
        case let .channelClosed(channelId,userChannelId,counterpartyNodeId,reason):
            writeInt(&buf, Int32(7))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterOptionTypeClosureReason.write(reason, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}


extension Event: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LightningBalance {
    
    case claimableOnChannelClose(
        channelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        amountSatoshis: UInt64
    )
    case claimableAwaitingConfirmations(
        channelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        amountSatoshis: UInt64, 
        confirmationHeight: UInt32
    )
    case contentiousClaimable(
        channelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        amountSatoshis: UInt64, 
        timeoutHeight: UInt32, 
        paymentHash: PaymentHash, 
        paymentPreimage: PaymentPreimage
    )
    case maybeTimeoutClaimableHtlc(
        channelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        amountSatoshis: UInt64, 
        claimableHeight: UInt32, 
        paymentHash: PaymentHash
    )
    case maybePreimageClaimableHtlc(
        channelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        amountSatoshis: UInt64, 
        expiryHeight: UInt32, 
        paymentHash: PaymentHash
    )
    case counterpartyRevokedOutputClaimable(
        channelId: ChannelId, 
        counterpartyNodeId: PublicKey, 
        amountSatoshis: UInt64
    )
}

public struct FfiConverterTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = LightningBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .claimableOnChannelClose(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .claimableAwaitingConfirmations(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf), 
            confirmationHeight: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .contentiousClaimable(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf), 
            timeoutHeight: try FfiConverterUInt32.read(from: &buf), 
            paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), 
            paymentPreimage: try FfiConverterTypePaymentPreimage.read(from: &buf)
        )
        
        case 4: return .maybeTimeoutClaimableHtlc(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf), 
            claimableHeight: try FfiConverterUInt32.read(from: &buf), 
            paymentHash: try FfiConverterTypePaymentHash.read(from: &buf)
        )
        
        case 5: return .maybePreimageClaimableHtlc(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf), 
            expiryHeight: try FfiConverterUInt32.read(from: &buf), 
            paymentHash: try FfiConverterTypePaymentHash.read(from: &buf)
        )
        
        case 6: return .counterpartyRevokedOutputClaimable(
            channelId: try FfiConverterTypeChannelId.read(from: &buf), 
            counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LightningBalance, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .claimableOnChannelClose(channelId,counterpartyNodeId,amountSatoshis):
            writeInt(&buf, Int32(1))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        
        case let .claimableAwaitingConfirmations(channelId,counterpartyNodeId,amountSatoshis,confirmationHeight):
            writeInt(&buf, Int32(2))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            
        
        case let .contentiousClaimable(channelId,counterpartyNodeId,amountSatoshis,timeoutHeight,paymentHash,paymentPreimage):
            writeInt(&buf, Int32(3))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(timeoutHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterTypePaymentPreimage.write(paymentPreimage, into: &buf)
            
        
        case let .maybeTimeoutClaimableHtlc(channelId,counterpartyNodeId,amountSatoshis,claimableHeight,paymentHash):
            writeInt(&buf, Int32(4))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(claimableHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            
        
        case let .maybePreimageClaimableHtlc(channelId,counterpartyNodeId,amountSatoshis,expiryHeight,paymentHash):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(expiryHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            
        
        case let .counterpartyRevokedOutputClaimable(channelId,counterpartyNodeId,amountSatoshis):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLightningBalance_lift(_ buf: RustBuffer) throws -> LightningBalance {
    return try FfiConverterTypeLightningBalance.lift(buf)
}

public func FfiConverterTypeLightningBalance_lower(_ value: LightningBalance) -> RustBuffer {
    return FfiConverterTypeLightningBalance.lower(value)
}


extension LightningBalance: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LogLevel {
    
    case gossip
    case trace
    case debug
    case info
    case warn
    case error
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gossip
        
        case 2: return .trace
        
        case 3: return .debug
        
        case 4: return .info
        
        case 5: return .warn
        
        case 6: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .gossip:
            writeInt(&buf, Int32(1))
        
        
        case .trace:
            writeInt(&buf, Int32(2))
        
        
        case .debug:
            writeInt(&buf, Int32(3))
        
        
        case .info:
            writeInt(&buf, Int32(4))
        
        
        case .warn:
            writeInt(&buf, Int32(5))
        
        
        case .error:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case bitcoin
    case testnet
    case signet
    case regtest
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}




public enum NodeError {

    
    
    case AlreadyRunning(message: String)
    
    case NotRunning(message: String)
    
    case OnchainTxCreationFailed(message: String)
    
    case ConnectionFailed(message: String)
    
    case InvoiceCreationFailed(message: String)
    
    case InvoiceRequestCreationFailed(message: String)
    
    case OfferCreationFailed(message: String)
    
    case RefundCreationFailed(message: String)
    
    case PaymentSendingFailed(message: String)
    
    case ProbeSendingFailed(message: String)
    
    case ChannelCreationFailed(message: String)
    
    case ChannelClosingFailed(message: String)
    
    case ChannelConfigUpdateFailed(message: String)
    
    case PersistenceFailed(message: String)
    
    case FeerateEstimationUpdateFailed(message: String)
    
    case FeerateEstimationUpdateTimeout(message: String)
    
    case WalletOperationFailed(message: String)
    
    case WalletOperationTimeout(message: String)
    
    case OnchainTxSigningFailed(message: String)
    
    case MessageSigningFailed(message: String)
    
    case TxSyncFailed(message: String)
    
    case TxSyncTimeout(message: String)
    
    case GossipUpdateFailed(message: String)
    
    case GossipUpdateTimeout(message: String)
    
    case LiquidityRequestFailed(message: String)
    
    case InvalidAddress(message: String)
    
    case InvalidSocketAddress(message: String)
    
    case InvalidPublicKey(message: String)
    
    case InvalidSecretKey(message: String)
    
    case InvalidOfferId(message: String)
    
    case InvalidNodeId(message: String)
    
    case InvalidPaymentId(message: String)
    
    case InvalidPaymentHash(message: String)
    
    case InvalidPaymentPreimage(message: String)
    
    case InvalidPaymentSecret(message: String)
    
    case InvalidAmount(message: String)
    
    case InvalidInvoice(message: String)
    
    case InvalidOffer(message: String)
    
    case InvalidRefund(message: String)
    
    case InvalidChannelId(message: String)
    
    case InvalidNetwork(message: String)
    
    case DuplicatePayment(message: String)
    
    case UnsupportedCurrency(message: String)
    
    case InsufficientFunds(message: String)
    
    case LiquiditySourceUnavailable(message: String)
    
    case LiquidityFeeTooHigh(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeNodeError.lift(error)
    }
}


public struct FfiConverterTypeNodeError: FfiConverterRustBuffer {
    typealias SwiftType = NodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AlreadyRunning(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .NotRunning(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .OnchainTxCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .ConnectionFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvoiceCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvoiceRequestCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .OfferCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .RefundCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .PaymentSendingFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .ProbeSendingFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .ChannelCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .ChannelClosingFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .ChannelConfigUpdateFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .PersistenceFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .FeerateEstimationUpdateFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .FeerateEstimationUpdateTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .WalletOperationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .WalletOperationTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 19: return .OnchainTxSigningFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .MessageSigningFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .TxSyncFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .TxSyncTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 23: return .GossipUpdateFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 24: return .GossipUpdateTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 25: return .LiquidityRequestFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .InvalidAddress(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .InvalidSocketAddress(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 28: return .InvalidPublicKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 29: return .InvalidSecretKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 30: return .InvalidOfferId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .InvalidNodeId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 32: return .InvalidPaymentId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 33: return .InvalidPaymentHash(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 34: return .InvalidPaymentPreimage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 35: return .InvalidPaymentSecret(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 36: return .InvalidAmount(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 37: return .InvalidInvoice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 38: return .InvalidOffer(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 39: return .InvalidRefund(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 40: return .InvalidChannelId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 41: return .InvalidNetwork(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 42: return .DuplicatePayment(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 43: return .UnsupportedCurrency(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 44: return .InsufficientFunds(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 45: return .LiquiditySourceUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 46: return .LiquidityFeeTooHigh(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .AlreadyRunning(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .NotRunning(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .OnchainTxCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .ConnectionFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvoiceCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvoiceRequestCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .OfferCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .RefundCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .PaymentSendingFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .ProbeSendingFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .ChannelCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .ChannelClosingFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .ChannelConfigUpdateFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .PersistenceFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .FeerateEstimationUpdateFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .FeerateEstimationUpdateTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .WalletOperationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))
        case .WalletOperationTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(18))
        case .OnchainTxSigningFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(19))
        case .MessageSigningFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(20))
        case .TxSyncFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(21))
        case .TxSyncTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(22))
        case .GossipUpdateFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(23))
        case .GossipUpdateTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(24))
        case .LiquidityRequestFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(25))
        case .InvalidAddress(_ /* message is ignored*/):
            writeInt(&buf, Int32(26))
        case .InvalidSocketAddress(_ /* message is ignored*/):
            writeInt(&buf, Int32(27))
        case .InvalidPublicKey(_ /* message is ignored*/):
            writeInt(&buf, Int32(28))
        case .InvalidSecretKey(_ /* message is ignored*/):
            writeInt(&buf, Int32(29))
        case .InvalidOfferId(_ /* message is ignored*/):
            writeInt(&buf, Int32(30))
        case .InvalidNodeId(_ /* message is ignored*/):
            writeInt(&buf, Int32(31))
        case .InvalidPaymentId(_ /* message is ignored*/):
            writeInt(&buf, Int32(32))
        case .InvalidPaymentHash(_ /* message is ignored*/):
            writeInt(&buf, Int32(33))
        case .InvalidPaymentPreimage(_ /* message is ignored*/):
            writeInt(&buf, Int32(34))
        case .InvalidPaymentSecret(_ /* message is ignored*/):
            writeInt(&buf, Int32(35))
        case .InvalidAmount(_ /* message is ignored*/):
            writeInt(&buf, Int32(36))
        case .InvalidInvoice(_ /* message is ignored*/):
            writeInt(&buf, Int32(37))
        case .InvalidOffer(_ /* message is ignored*/):
            writeInt(&buf, Int32(38))
        case .InvalidRefund(_ /* message is ignored*/):
            writeInt(&buf, Int32(39))
        case .InvalidChannelId(_ /* message is ignored*/):
            writeInt(&buf, Int32(40))
        case .InvalidNetwork(_ /* message is ignored*/):
            writeInt(&buf, Int32(41))
        case .DuplicatePayment(_ /* message is ignored*/):
            writeInt(&buf, Int32(42))
        case .UnsupportedCurrency(_ /* message is ignored*/):
            writeInt(&buf, Int32(43))
        case .InsufficientFunds(_ /* message is ignored*/):
            writeInt(&buf, Int32(44))
        case .LiquiditySourceUnavailable(_ /* message is ignored*/):
            writeInt(&buf, Int32(45))
        case .LiquidityFeeTooHigh(_ /* message is ignored*/):
            writeInt(&buf, Int32(46))

        
        }
    }
}


extension NodeError: Equatable, Hashable {}

extension NodeError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentDirection {
    
    case inbound
    case outbound
}

public struct FfiConverterTypePaymentDirection: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inbound
        
        case 2: return .outbound
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inbound:
            writeInt(&buf, Int32(1))
        
        
        case .outbound:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePaymentDirection_lift(_ buf: RustBuffer) throws -> PaymentDirection {
    return try FfiConverterTypePaymentDirection.lift(buf)
}

public func FfiConverterTypePaymentDirection_lower(_ value: PaymentDirection) -> RustBuffer {
    return FfiConverterTypePaymentDirection.lower(value)
}


extension PaymentDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentFailureReason {
    
    case recipientRejected
    case userAbandoned
    case retriesExhausted
    case paymentExpired
    case routeNotFound
    case unexpectedError
}

public struct FfiConverterTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFailureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .recipientRejected
        
        case 2: return .userAbandoned
        
        case 3: return .retriesExhausted
        
        case 4: return .paymentExpired
        
        case 5: return .routeNotFound
        
        case 6: return .unexpectedError
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentFailureReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .recipientRejected:
            writeInt(&buf, Int32(1))
        
        
        case .userAbandoned:
            writeInt(&buf, Int32(2))
        
        
        case .retriesExhausted:
            writeInt(&buf, Int32(3))
        
        
        case .paymentExpired:
            writeInt(&buf, Int32(4))
        
        
        case .routeNotFound:
            writeInt(&buf, Int32(5))
        
        
        case .unexpectedError:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypePaymentFailureReason_lift(_ buf: RustBuffer) throws -> PaymentFailureReason {
    return try FfiConverterTypePaymentFailureReason.lift(buf)
}

public func FfiConverterTypePaymentFailureReason_lower(_ value: PaymentFailureReason) -> RustBuffer {
    return FfiConverterTypePaymentFailureReason.lower(value)
}


extension PaymentFailureReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentKind {
    
    case onchain
    case bolt11(
        hash: PaymentHash, 
        preimage: PaymentPreimage?, 
        secret: PaymentSecret?
    )
    case bolt11Jit(
        hash: PaymentHash, 
        preimage: PaymentPreimage?, 
        secret: PaymentSecret?, 
        lspFeeLimits: LspFeeLimits
    )
    case bolt12Offer(
        hash: PaymentHash?, 
        preimage: PaymentPreimage?, 
        secret: PaymentSecret?, 
        offerId: OfferId
    )
    case bolt12Refund(
        hash: PaymentHash?, 
        preimage: PaymentPreimage?, 
        secret: PaymentSecret?
    )
    case spontaneous(
        hash: PaymentHash, 
        preimage: PaymentPreimage?
    )
}

public struct FfiConverterTypePaymentKind: FfiConverterRustBuffer {
    typealias SwiftType = PaymentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .onchain
        
        case 2: return .bolt11(
            hash: try FfiConverterTypePaymentHash.read(from: &buf), 
            preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), 
            secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf)
        )
        
        case 3: return .bolt11Jit(
            hash: try FfiConverterTypePaymentHash.read(from: &buf), 
            preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), 
            secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf), 
            lspFeeLimits: try FfiConverterTypeLSPFeeLimits.read(from: &buf)
        )
        
        case 4: return .bolt12Offer(
            hash: try FfiConverterOptionTypePaymentHash.read(from: &buf), 
            preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), 
            secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf), 
            offerId: try FfiConverterTypeOfferId.read(from: &buf)
        )
        
        case 5: return .bolt12Refund(
            hash: try FfiConverterOptionTypePaymentHash.read(from: &buf), 
            preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), 
            secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf)
        )
        
        case 6: return .spontaneous(
            hash: try FfiConverterTypePaymentHash.read(from: &buf), 
            preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .onchain:
            writeInt(&buf, Int32(1))
        
        
        case let .bolt11(hash,preimage,secret):
            writeInt(&buf, Int32(2))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            
        
        case let .bolt11Jit(hash,preimage,secret,lspFeeLimits):
            writeInt(&buf, Int32(3))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterTypeLSPFeeLimits.write(lspFeeLimits, into: &buf)
            
        
        case let .bolt12Offer(hash,preimage,secret,offerId):
            writeInt(&buf, Int32(4))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterTypeOfferId.write(offerId, into: &buf)
            
        
        case let .bolt12Refund(hash,preimage,secret):
            writeInt(&buf, Int32(5))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            
        
        case let .spontaneous(hash,preimage):
            writeInt(&buf, Int32(6))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            
        }
    }
}


public func FfiConverterTypePaymentKind_lift(_ buf: RustBuffer) throws -> PaymentKind {
    return try FfiConverterTypePaymentKind.lift(buf)
}

public func FfiConverterTypePaymentKind_lower(_ value: PaymentKind) -> RustBuffer {
    return FfiConverterTypePaymentKind.lower(value)
}


extension PaymentKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentStatus {
    
    case pending
    case succeeded
    case failed
}

public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .succeeded
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .succeeded:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}


extension PaymentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PendingSweepBalance {
    
    case pendingBroadcast(
        channelId: ChannelId?, 
        amountSatoshis: UInt64
    )
    case broadcastAwaitingConfirmation(
        channelId: ChannelId?, 
        latestBroadcastHeight: UInt32, 
        latestSpendingTxid: Txid, 
        amountSatoshis: UInt64
    )
    case awaitingThresholdConfirmations(
        channelId: ChannelId?, 
        latestSpendingTxid: Txid, 
        confirmationHash: BlockHash, 
        confirmationHeight: UInt32, 
        amountSatoshis: UInt64
    )
}

public struct FfiConverterTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = PendingSweepBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingSweepBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pendingBroadcast(
            channelId: try FfiConverterOptionTypeChannelId.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .broadcastAwaitingConfirmation(
            channelId: try FfiConverterOptionTypeChannelId.read(from: &buf), 
            latestBroadcastHeight: try FfiConverterUInt32.read(from: &buf), 
            latestSpendingTxid: try FfiConverterTypeTxid.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .awaitingThresholdConfirmations(
            channelId: try FfiConverterOptionTypeChannelId.read(from: &buf), 
            latestSpendingTxid: try FfiConverterTypeTxid.read(from: &buf), 
            confirmationHash: try FfiConverterTypeBlockHash.read(from: &buf), 
            confirmationHeight: try FfiConverterUInt32.read(from: &buf), 
            amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingSweepBalance, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pendingBroadcast(channelId,amountSatoshis):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        
        case let .broadcastAwaitingConfirmation(channelId,latestBroadcastHeight,latestSpendingTxid,amountSatoshis):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt32.write(latestBroadcastHeight, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        
        case let .awaitingThresholdConfirmations(channelId,latestSpendingTxid,confirmationHash,confirmationHeight,amountSatoshis):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterTypeBlockHash.write(confirmationHash, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        }
    }
}


public func FfiConverterTypePendingSweepBalance_lift(_ buf: RustBuffer) throws -> PendingSweepBalance {
    return try FfiConverterTypePendingSweepBalance.lift(buf)
}

public func FfiConverterTypePendingSweepBalance_lower(_ value: PendingSweepBalance) -> RustBuffer {
    return FfiConverterTypePendingSweepBalance.lower(value)
}


extension PendingSweepBalance: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelConfig: FfiConverterRustBuffer {
    typealias SwiftType = ChannelConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    typealias SwiftType = AnchorChannelsConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAnchorChannelsConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAnchorChannelsConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelUpdateInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelUpdateInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelUpdateInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelUpdateInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeAnnouncementInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeAnnouncementInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeAnnouncementInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNodeInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = OutPoint?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutPoint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutPoint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClosureReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClosureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEvent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEvent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentFailureReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentFailureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeSocketAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeSocketAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelId: FfiConverterRustBuffer {
    typealias SwiftType = ChannelId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentHash: FfiConverterRustBuffer {
    typealias SwiftType = PaymentHash?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentHash.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentHash.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentId: FfiConverterRustBuffer {
    typealias SwiftType = PaymentId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentPreimage: FfiConverterRustBuffer {
    typealias SwiftType = PaymentPreimage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentPreimage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentPreimage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentSecret: FfiConverterRustBuffer {
    typealias SwiftType = PaymentSecret?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentSecret.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentSecret.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeChannelDetails: FfiConverterRustBuffer {
    typealias SwiftType = [ChannelDetails]

    public static func write(_ value: [ChannelDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChannelDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChannelDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChannelDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChannelDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentDetails]

    public static func write(_ value: [PaymentDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePeerDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PeerDetails]

    public static func write(_ value: [PeerDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePeerDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PeerDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PeerDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePeerDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = [LightningBalance]

    public static func write(_ value: [LightningBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLightningBalance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LightningBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [LightningBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLightningBalance.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = [PendingSweepBalance]

    public static func write(_ value: [PendingSweepBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePendingSweepBalance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PendingSweepBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [PendingSweepBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePendingSweepBalance.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNodeId: FfiConverterRustBuffer {
    typealias SwiftType = [NodeId]

    public static func write(_ value: [NodeId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]

    public static func write(_ value: [SocketAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSocketAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SocketAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [SocketAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSocketAddress.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Address = String
public struct FfiConverterTypeAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Address {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Address) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeAddress_lift(_ value: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(value)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BlockHash = String
public struct FfiConverterTypeBlockHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BlockHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BlockHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BlockHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeBlockHash_lift(_ value: RustBuffer) throws -> BlockHash {
    return try FfiConverterTypeBlockHash.lift(value)
}

public func FfiConverterTypeBlockHash_lower(_ value: BlockHash) -> RustBuffer {
    return FfiConverterTypeBlockHash.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bolt11Invoice = String
public struct FfiConverterTypeBolt11Invoice: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Invoice {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bolt11Invoice, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bolt11Invoice {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bolt11Invoice) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeBolt11Invoice_lift(_ value: RustBuffer) throws -> Bolt11Invoice {
    return try FfiConverterTypeBolt11Invoice.lift(value)
}

public func FfiConverterTypeBolt11Invoice_lower(_ value: Bolt11Invoice) -> RustBuffer {
    return FfiConverterTypeBolt11Invoice.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bolt12Invoice = String
public struct FfiConverterTypeBolt12Invoice: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Invoice {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bolt12Invoice, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bolt12Invoice {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bolt12Invoice) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeBolt12Invoice_lift(_ value: RustBuffer) throws -> Bolt12Invoice {
    return try FfiConverterTypeBolt12Invoice.lift(value)
}

public func FfiConverterTypeBolt12Invoice_lower(_ value: Bolt12Invoice) -> RustBuffer {
    return FfiConverterTypeBolt12Invoice.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ChannelId = String
public struct FfiConverterTypeChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeChannelId_lift(_ value: RustBuffer) throws -> ChannelId {
    return try FfiConverterTypeChannelId.lift(value)
}

public func FfiConverterTypeChannelId_lower(_ value: ChannelId) -> RustBuffer {
    return FfiConverterTypeChannelId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Mnemonic = String
public struct FfiConverterTypeMnemonic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Mnemonic {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Mnemonic) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeMnemonic_lift(_ value: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(value)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeId = String
public struct FfiConverterTypeNodeId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeNodeId_lift(_ value: RustBuffer) throws -> NodeId {
    return try FfiConverterTypeNodeId.lift(value)
}

public func FfiConverterTypeNodeId_lower(_ value: NodeId) -> RustBuffer {
    return FfiConverterTypeNodeId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Offer = String
public struct FfiConverterTypeOffer: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Offer {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Offer, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Offer {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Offer) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeOffer_lift(_ value: RustBuffer) throws -> Offer {
    return try FfiConverterTypeOffer.lift(value)
}

public func FfiConverterTypeOffer_lower(_ value: Offer) -> RustBuffer {
    return FfiConverterTypeOffer.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias OfferId = String
public struct FfiConverterTypeOfferId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: OfferId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> OfferId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: OfferId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeOfferId_lift(_ value: RustBuffer) throws -> OfferId {
    return try FfiConverterTypeOfferId.lift(value)
}

public func FfiConverterTypeOfferId_lower(_ value: OfferId) -> RustBuffer {
    return FfiConverterTypeOfferId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentHash = String
public struct FfiConverterTypePaymentHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentHash_lift(_ value: RustBuffer) throws -> PaymentHash {
    return try FfiConverterTypePaymentHash.lift(value)
}

public func FfiConverterTypePaymentHash_lower(_ value: PaymentHash) -> RustBuffer {
    return FfiConverterTypePaymentHash.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentId = String
public struct FfiConverterTypePaymentId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentId_lift(_ value: RustBuffer) throws -> PaymentId {
    return try FfiConverterTypePaymentId.lift(value)
}

public func FfiConverterTypePaymentId_lower(_ value: PaymentId) -> RustBuffer {
    return FfiConverterTypePaymentId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentPreimage = String
public struct FfiConverterTypePaymentPreimage: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentPreimage {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentPreimage, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentPreimage {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentPreimage) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentPreimage_lift(_ value: RustBuffer) throws -> PaymentPreimage {
    return try FfiConverterTypePaymentPreimage.lift(value)
}

public func FfiConverterTypePaymentPreimage_lower(_ value: PaymentPreimage) -> RustBuffer {
    return FfiConverterTypePaymentPreimage.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentSecret = String
public struct FfiConverterTypePaymentSecret: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentSecret {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentSecret, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentSecret {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentSecret) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentSecret_lift(_ value: RustBuffer) throws -> PaymentSecret {
    return try FfiConverterTypePaymentSecret.lift(value)
}

public func FfiConverterTypePaymentSecret_lower(_ value: PaymentSecret) -> RustBuffer {
    return FfiConverterTypePaymentSecret.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PublicKey = String
public struct FfiConverterTypePublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PublicKey {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PublicKey) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePublicKey_lift(_ value: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(value)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Refund = String
public struct FfiConverterTypeRefund: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Refund {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Refund, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Refund {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Refund) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeRefund_lift(_ value: RustBuffer) throws -> Refund {
    return try FfiConverterTypeRefund.lift(value)
}

public func FfiConverterTypeRefund_lower(_ value: Refund) -> RustBuffer {
    return FfiConverterTypeRefund.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SocketAddress = String
public struct FfiConverterTypeSocketAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SocketAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: SocketAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SocketAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: SocketAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeSocketAddress_lift(_ value: RustBuffer) throws -> SocketAddress {
    return try FfiConverterTypeSocketAddress.lift(value)
}

public func FfiConverterTypeSocketAddress_lower(_ value: SocketAddress) -> RustBuffer {
    return FfiConverterTypeSocketAddress.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Txid = String
public struct FfiConverterTypeTxid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Txid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Txid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Txid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Txid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeTxid_lift(_ value: RustBuffer) throws -> Txid {
    return try FfiConverterTypeTxid.lift(value)
}

public func FfiConverterTypeTxid_lower(_ value: Txid) -> RustBuffer {
    return FfiConverterTypeTxid.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UntrustedString = String
public struct FfiConverterTypeUntrustedString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UntrustedString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UntrustedString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UntrustedString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UntrustedString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUntrustedString_lift(_ value: RustBuffer) throws -> UntrustedString {
    return try FfiConverterTypeUntrustedString.lift(value)
}

public func FfiConverterTypeUntrustedString_lower(_ value: UntrustedString) -> RustBuffer {
    return FfiConverterTypeUntrustedString.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UserChannelId = String
public struct FfiConverterTypeUserChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UserChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UserChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UserChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUserChannelId_lift(_ value: RustBuffer) throws -> UserChannelId {
    return try FfiConverterTypeUserChannelId.lift(value)
}

public func FfiConverterTypeUserChannelId_lower(_ value: UserChannelId) -> RustBuffer {
    return FfiConverterTypeUserChannelId.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UnsafeMutableRawPointer,
    pollFunc: (UnsafeMutableRawPointer, @escaping UniFfiRustFutureContinuation, UnsafeMutableRawPointer) -> (),
    completeFunc: (UnsafeMutableRawPointer, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UnsafeMutableRawPointer) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    
    var pollResult: Int8 = 0 // Initialize pollResult before use
    
    repeat {
        if #available(iOS 13.0, *) {
            pollResult = await withUnsafeContinuation {
                pollFunc(rustFuture, uniffiFutureContinuationCallback, ContinuationHolder($0).toOpaque())
            }
        } else {
            // Fallback on earlier versions
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}


// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(ptr: UnsafeMutableRawPointer, pollResult: Int8) {
    if #available(iOS 13.0, *) {
        ContinuationHolder.fromOpaque(ptr).resume(pollResult)
    } else {
        // Fallback on earlier versions
    }
}

// Wraps UnsafeContinuation in a class so that we can use reference counting when passing it across
// the FFI
@available(iOS 13.0, *)
fileprivate class ContinuationHolder {
    let continuation: UnsafeContinuation<Int8, Never>

    init(_ continuation: UnsafeContinuation<Int8, Never>) {
        self.continuation = continuation
    }

    func resume(_ pollResult: Int8) {
        self.continuation.resume(returning: pollResult)
    }

    func toOpaque() -> UnsafeMutableRawPointer {
        return Unmanaged<ContinuationHolder>.passRetained(self).toOpaque()
    }

    static func fromOpaque(_ ptr: UnsafeRawPointer) -> ContinuationHolder {
        return Unmanaged<ContinuationHolder>.fromOpaque(ptr).takeRetainedValue()
    }
}
public func defaultConfig()  -> Config {
    return try!  FfiConverterTypeConfig.lift(
        try! rustCall() {
    uniffi_ldk_node_fn_func_default_config($0)
}
    )
}
public func generateEntropyMnemonic()  -> Mnemonic {
    return try!  FfiConverterTypeMnemonic.lift(
        try! rustCall() {
    uniffi_ldk_node_fn_func_generate_entropy_mnemonic($0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_ldk_node_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_ldk_node_checksum_func_default_config() != 55381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_func_generate_entropy_mnemonic() != 59926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_claim_for_hash() != 52848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_fail_for_hash() != 24516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive() != 28084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_for_hash() != 3869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount() != 51453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_for_hash() != 21975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel() != 58617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel() != 50555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send() != 35346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send_probes() != 39625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send_probes_using_amount() != 25010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send_using_amount() != 15471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_initiate_refund() != 15379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_receive() != 20864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_receive_variable_amount() != 10863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_request_refund_payment() != 61945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_send() != 15282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_send_using_amount() != 21384) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_build() != 785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_build_with_fs_store() != 61304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_entropy_bip39_mnemonic() != 827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_entropy_seed_bytes() != 44799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_entropy_seed_path() != 64056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_esplora_server() != 7044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_gossip_source_p2p() != 9279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_gossip_source_rgs() != 64312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps2() != 2667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_listening_addresses() != 14051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_network() != 27539) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_storage_dir_path() != 59019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_accept_underpaying_htlcs() != 45655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_cltv_expiry_delta() != 19044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_force_close_avoidance_max_fee_satoshis() != 69) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_forwarding_fee_base_msat() != 3400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_forwarding_fee_proportional_millionths() != 31794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_set_accept_underpaying_htlcs() != 27275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_set_cltv_expiry_delta() != 40735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_set_force_close_avoidance_max_fee_satoshis() != 48479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_set_forwarding_fee_base_msat() != 29831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_set_forwarding_fee_proportional_millionths() != 65060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_set_max_dust_htlc_exposure_from_fee_rate_multiplier() != 4707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_channelconfig_set_max_dust_htlc_exposure_from_fixed_limit() != 16864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_channel() != 38070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_list_channels() != 4693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_list_nodes() != 36715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_node() != 48925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_bolt11_payment() != 41402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_bolt12_payment() != 49254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_close_channel() != 62479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_config() != 7511) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_connect() != 34120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_connect_open_channel() != 64763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_disconnect() != 43538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_event_handled() != 47939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_force_close_channel() != 44813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_balances() != 57528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_channels() != 7954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_payments() != 35002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_peers() != 14889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_listening_addresses() != 2665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_network_graph() != 2695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_next_event() != 7682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_next_event_async() != 25426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_node_id() != 51489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_onchain_payment() != 6092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_payment() != 60296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_remove_payment() != 47952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_sign_message() != 51392) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_spontaneous_payment() != 37403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_start() != 58480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_status() != 55952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_stop() != 42188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_sync_wallets() != 32474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_update_channel_config() != 38109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_verify_signature() != 20486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_wait_next_event() != 55101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_onchainpayment_new_address() != 37251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_onchainpayment_send_all_to_address() != 20046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_onchainpayment_send_to_address() != 34782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_spontaneouspayment_send() != 16613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_spontaneouspayment_send_probes() != 25937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_builder_from_config() != 64393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_builder_new() != 48442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_channelconfig_new() != 24987) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
